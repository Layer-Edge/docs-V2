---
sidebar_position: 2
---

# Verification Layer

The Verification Layer is the top stage of the LayerEdge proof pipeline. It serves as the entry point for de/re-
rolled proofs generated by external protocols—ranging from simple application-specific SNARKs to advanced 
zk-validated STARK systems.

This layer ensures:

* All proofs are **normalized** to a common format, regardless of their cryptographic origin
* Only structurally and cryptographically **valid proofs** are passed downstream for aggregation
* Throughput and flexibility are maintained even as new zk-proof formats emerge

## Purpose and Role

The Verification Layer performs two core responsibilities:

### Proof Intake

Accepts zkProofs from a wide variety of proving systems, including but not limited to:

* **SNARKs**
  * GrOTH16 (e.g., used in Tornado Cash, Semaphore)
  * PLONK / TurboCSVM (e.g., zkSync)
  * Halo2, Nova (interoperability)

* **STARKs**
  * AirSTARK
  * Fractal
  * ZKVMs such as RISC Zero and BPI

This layer abstracts away the cryptographic specifics and allows LayerEdge to support **heterogeneous zk ecosystems**.

### Proof Normalization

Each submitted proof is normalized into a **standard intermediate format** that can be consumed by downstream recursive circuits and aggregator logic.

This includes:

* Canonicalized data and group encoding
* Common curve representation
* Unified public input serialization
* Flattened proof metadata

## Technical Breakdown

### Interface Definition

Proof producers interact with the Verification Layer using standardized APIs (e.g., gRPC or REST). The following data must be submitted:

* **ProofData**: Raw binary or serialized proof
* **ProofMetadata**: Cryptographic context for interpreting and validating the proof

### What ProofMetadata Includes

* **Curve Identifiers**: e.g., BN254, BLS12-377, BLS12-381
* **Proof Length**: Byte length of the serialized proof
* **Public Input Count**: Number of inputs used in the zk computation
* **Verification Key Reference**: Hash or ID referencing an on-chain or off-chain verification key or commitment

### Normalization Logic

The Verification Layer applies format-specific normalization rules depending on the proof system.

#### For SnarkR

* Extract and reorder elliptic curve points (A, B, C)
* Convert compressed curve points into **uncompressed affine coordinates**
* Standardize encoding over the expected field (e.g., BLS12-381)

#### For STARK-based Systems

* Extract FRI commitments and Merkle metrics
* Normalize polynomial evaluations and low-degree test claims
* Flatten STARK proofs into a "standard claim structure" used for aggregation

#### For ZKVM Proofs (e.g., RISC Zero / BPI)

* Capture execution trace commitments, journal data, and memory hashes
* Normalize field elements (Poseidon-based) into scalar representations
* Canonized public input digest for circuit compatibility

## Validation & Error Handling

Before forwarding any proof to the aggregation system, the Verification Layer ensures:

* **Elliptic Curve Group Membership**: Each curve point must lie on its intended curve
* **Correct Length**: Proof byte count strictly matches values per system
* **Input Bounds**: Public input size must not exceed circuit limits
* **Structural Sanity**: Valid encoding, byte formatting, compression flags, etc.

Proofs failing any of these checks are rejected **immediately** to protect downstream logic.

## Key Innovations

### Adaptive Normalization Pipelines

The Verification Layer is modular by design. Each zk-proof system (e.g., Groth16, PLONK, STARK) is handled by a separate normalization subroutine. New formats can be added without requiring rewrites of aggregation logic.

This ensures LayerEdge remains compatible with:

* Non-pairing proof systems (e.g., LIGNIN-ONE, zkSNARK, BRAHMA)
* Roll-ups/ede zk circuits
* ZKMs and Rust/solidity provers

### Parallel Queues for Scalability

Proof normalization is highly parallelized. The system creates **per-system queues**, meaning Groth16, STARK, and ZKVM-based proofs are parsed concurrently—maximizing throughput.

Queue isolation also prevents a malformed batch in one system from delaying others.

## Future Considerations

As more zk-proving frameworks emerge, the Verification Layer is expected to support:

* **Multi-proof submissions**: For batch uploads from ridge repositories
* **Custom verification key schemas**: For ZKML, recursive rollups, etc.
* **On-chain key registration**: Allowing verification keys to be published as commitments and referenced trustlessly during normalization

## Summary

| Feature | Description |
|---------|-------------|
| Proof Types Supported | Groth16, PLONK, Halo2, STARKs (AirSTARK, Fractal, ZKVMs (RISC, BPI)) |  
| Normalization Output | Canonical curve elements, normalized field/EC claims, unified metadata |
| API | REST/gRPC endpoints for submission |
| Validation | Curve checks, proof length, public input count, format sanity |
| Scalability | Parallel queues, modular normalization, upgradable schema |

---

< Proof Aggregation Layer | General Prover / Verifier System >

Last updated 3 days ago